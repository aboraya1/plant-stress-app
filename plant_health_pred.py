# -*- coding: utf-8 -*-
"""plant_health_pred.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RX08nBlgJdifsmOJhB_I51t0Nu0LBNQT
"""

!pip install streamlit pyngrok --quiet

# Plant Health Prediction - Improved Version

## 1. Import Libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.preprocessing import StandardScaler
import joblib

## 2. Load Dataset
df = pd.read_csv("updated_plant_health_data.csv")
df.head()

## 3. Data Preprocessing
# Map categorical values
df['Plant_Health_Status'] = df['Plant_Health_Status'].map({
    'Healthy': 0,
    'Moderate Stress': 1,
    'High Stress': 2
})
df['Type'] = df['Type'].map({
    'Desert': 0,
    'Agricultural': 1,
    'Shade': 2
})

## 4. Exploratory Data Analysis (EDA)
# Plot class distribution
plt.figure(figsize=(6, 4))
df['Plant_Health_Status'].value_counts().plot(kind='bar', color=['green', 'gold', 'red'])
plt.title("Class Distribution")
plt.xlabel("Plant Health Status")
plt.ylabel("Count")
plt.xticks(ticks=[0,1,2], labels=['Healthy','Moderate Stress','High Stress'], rotation=0)
plt.tight_layout()
plt.show()



## 5. Feature Selection
features = ["Soil_Moisture", "Ambient_Temperature", "Soil_Temperature", "Humidity",
            "Light_Intensity", "Soil_pH", "Nitrogen_Level", "Phosphorus_Level",
            "Potassium_Level", "Chlorophyll_Content", "Electrochemical_Signal", "Type"]
X = df[features]
y = df["Plant_Health_Status"]

## 6. Feature Scaling
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

## 7. Train-Test Split
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

## 8. Model Training
model = RandomForestClassifier(n_estimators=100, class_weight='balanced', random_state=42)
model.fit(X_train, y_train)

## 9. Evaluation
y_pred = model.predict(X_test)
print("Classification Report:\n", classification_report(y_test, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))

## 10. Save Model and Scaler
joblib.dump(model, "plant_model_balanced.pkl")
joblib.dump(scaler, "plant_scaler.pkl")

print("\nModel and scaler saved successfully as 'plant_model_balanced.pkl' and 'plant_scaler.pkl'")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import numpy as np
# import pandas as pd
# import joblib
# import plotly.express as px
# 
# # ğŸ—¾ï¸ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
# st.set_page_config(page_title="ğŸŒ¿ Plant Health Dashboard", layout="wide")
# st.markdown("<h1 style='text-align: center; color: green;'>ğŸŒ¿ Plant Stress Detection Dashboard</h1>", unsafe_allow_html=True)
# st.markdown("---")
# 
# # ğŸ§ª Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠ
# st.sidebar.image("https://cdn-icons-png.flaticon.com/512/2900/2900583.png", width=120)
# st.sidebar.markdown("ğŸ‘‹ Welcome! This app predicts plant health status based on soil, weather & nutrients.")
# menu = st.sidebar.radio("ğŸ“ Navigate", ["ğŸ“‹ Predict", "ğŸ“Š Visualizations"])
# 
# # ğŸ“¦ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ÙˆØ§Ù„Ù…Ù‚ÙŠØ§Ø³
# @st.cache_resource
# def load_resources():
#     model = joblib.load("plant_model_balanced.pkl")
#     scaler = joblib.load("plant_scaler.pkl")
#     return model, scaler
# 
# model, scaler = load_resources()
# 
# 
# @st.cache_data
# def load_data():
#     return pd.read_csv("updated_plant_health_data.csv")
# 
# data = load_data()
# 
# # ğŸ”„ ØªÙ‡ÙŠØ¦Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ù„Ø³Ø©
# if "step" not in st.session_state:
#     st.session_state.step = 1
# 
# if "plant_type" not in st.session_state:
#     st.session_state.plant_type = None
# 
# def reset_prediction():
#     st.session_state.step = 1
#     st.session_state.plant_type = None
# 
# if menu == "ğŸ“‹ Predict":
#     if st.session_state.step == 1:
#         st.subheader("ğŸœï¸ Step 1: Choose Environment Type")
# 
#         with st.form("type_form"):
#             plant_env_type = st.selectbox("Select the Plant Environment Type", ["Desert", "Agricultural", "Shade"])
#             next_step = st.form_submit_button("â¡ Next")
# 
#         if next_step:
#             st.session_state.plant_type = plant_env_type
#             st.session_state.step = 2
#             st.rerun()
# 
#     elif st.session_state.step == 2:
#         st.subheader(f"ğŸ§ª Step 2: Enter Features for {st.session_state.plant_type} Area")
# 
#         with st.form("feature_form"):
#             col1, col2 = st.columns(2)
#             with col1:
#                 soil_moisture = st.slider("Soil Moisture", 0.0, 100.0, 25.0)
#                 ambient_temp = st.slider("Ambient Temperature", 0.0, 50.0, 25.0)
#                 soil_temp = st.slider("Soil Temperature", 0.0, 50.0, 25.0)
#                 humidity = st.slider("Humidity", 0.0, 100.0, 50.0)
#                 light_intensity = st.slider("Light Intensity", 0.0, 1000.0, 400.0)
# 
#             with col2:
#                 soil_ph = st.slider("Soil pH", 3.0, 9.0, 6.5)
#                 nitrogen = st.slider("Nitrogen Level", 0.0, 50.0, 15.0)
#                 phosphorus = st.slider("Phosphorus Level", 0.0, 50.0, 15.0)
#                 potassium = st.slider("Potassium Level", 0.0, 50.0, 15.0)
#                 chlorophyll = st.slider("Chlorophyll Content", 0.0, 100.0, 30.0)
#                 electro_signal = st.slider("Electrochemical Signal", 0.0, 2.0, 1.0)
# 
#             back = st.form_submit_button("ğŸ”™ Back")
#             submit = st.form_submit_button("ğŸŒ¿ Predict")
# 
#         if back:
#             reset_prediction()
#             st.rerun()
# 
#         if submit:
#             type_mapping = {"Desert": 0, "Agricultural": 1, "Shade": 2}
#             type_encoded = type_mapping[st.session_state.plant_type]
# 
#             input_data = np.array([[soil_moisture, ambient_temp, soil_temp, humidity, light_intensity,
#                                     soil_ph, nitrogen, phosphorus, potassium, chlorophyll, electro_signal, type_encoded]])
# 
#             input_scaled = scaler.transform(input_data)
#             prediction = model.predict(input_scaled)[0]
# 
#             status_map = {
#                 0: "âœ… Healthy Plant",
#                 1: "âš  Moderate Stress",
#                 2: "ğŸš¨ High Stress"
#             }
# 
#             st.success(f"**Prediction Result ({st.session_state.plant_type} Area):** {status_map[prediction]}")
# 
#             if prediction in [1, 2]:
#                 st.warning("ğŸ§º Recommended Actions to Improve Plant Health:")
#                 if soil_moisture < 30:
#                     st.info("ğŸ’§ Increase watering: Soil moisture is too low.")
#                 if nitrogen < 10:
#                     st.info("ğŸŒ± Apply nitrogen-rich fertilizer: Nitrogen level is insufficient.")
#                 if soil_ph < 5.5 or soil_ph > 7.5:
#                     st.info("ğŸ§ª Adjust soil pH: Ideal range is 5.5 to 7.5.")
#                 if light_intensity < 300:
#                     st.info("ğŸ”† Increase light exposure: Light intensity is lower than optimal.")
#                 if ambient_temp < 15 or ambient_temp > 35:
#                     st.info("ğŸŒ¡ï¸ Temperature adjustment: Keep ambient temperature between 15Â°C and 35Â°C.")
# 
#             st.button("ğŸ”„ Start Over", on_click=reset_prediction)
# 
# 
# elif menu == "ğŸ“Š Visualizations":
#     st.subheader("ğŸ“Š Explore Key Feature Impact on Plant Health")
# 
#     @st.cache_resource
#     def plot_feature_relation(x_feature):
#         data_numeric = data.copy()
#         mapping = {"Healthy": 0, "Moderate Stress": 1, "High Stress": 2}
#         if data_numeric["Plant_Health_Status"].dtype == object:
#             data_numeric["Plant_Health_Status"] = data_numeric["Plant_Health_Status"].map(mapping)
# 
#         avg_values = data_numeric.groupby("Plant_Health_Status")[x_feature].mean().reset_index()
# 
#         fig = px.bar(avg_values, x="Plant_Health_Status", y=x_feature,
#                      labels={"Plant_Health_Status": "Health Status", x_feature: f"Avg {x_feature}"},
#                      title=f"Average {x_feature} per Plant Health Status",
#                      color_discrete_sequence=["#4CAF50"])
# 
#         fig.update_layout(xaxis=dict(
#             tickmode="array",
#             tickvals=[0, 1, 2],
#             ticktext=["Healthy", "Moderate", "High Stress"]
#         ))
# 
#         return fig
# 
#     important_features = ["Soil_Moisture", "Nitrogen_Level"]
#     selected_feature = st.sidebar.selectbox("ğŸ“Œ Choose Feature", important_features)
#     plot = plot_feature_relation(selected_feature)
#     st.plotly_chart(plot, use_container_width=True)
# 
#     notes = {
#         "Soil_Moisture": "ğŸ’§ Dry soil often indicates high stress.",
#         "Nitrogen_Level": "ğŸŒ± Low nitrogen = weak growth."
#     }
# 
#     st.info(notes[selected_feature])

!streamlit run app.py &> /dev/null &

from pyngrok import ngrok

ngrok.kill()  # Ø¨ÙŠÙ‚ÙÙ„ ÙƒÙ„ Ø§Ù„Ø£Ù†ÙØ§Ù‚ Ø§Ù„Ù…ÙØªÙˆØ­Ø©

from pyngrok import ngrok

# Ø¶Ø¹ Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù…Ù† ngrok
ngrok.set_auth_token("2x5uKG1AyM2cbaScWFA4OLgQtK3_6w7ohUmRRohB1evn2FdE8")

public_url = ngrok.connect(addr="8501")
print("ğŸŒ Your Streamlit App is Live At:", public_url)

